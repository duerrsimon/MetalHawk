<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>MetalHawk.src.model_predictor API documentation</title>
<meta name="description" content="This module includes the main interface that handles the predictions." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>MetalHawk.src.model_predictor</code></h1>
</header>
<section id="section-intro">
<p>This module includes the main interface that handles the predictions.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module includes the main interface that handles the predictions.
&#34;&#34;&#34;

# Python import(s).
from pathlib import Path

import joblib
import warnings
import numpy as np

# Custom code imports.
from src.metal_pdb_data import MetalPdbData
from src.metal_auxiliaries import (fast_entropy,
                                   MD5_HASH_CODES)


# Predictor Class.
class MetalSitesPredictor(object):
    &#34;&#34;&#34;
    Metal Sites Predictor class. This is the &#34;wrapper&#34; class that performs the
    predictions in the input vectors. It processes the input (PDB) files, extracts
    the features and finally performs the prediction using pre-trained models.
    &#34;&#34;&#34;

    # Object variables.
    __slots__ = (&#34;nn_model&#34;, &#34;dir_model&#34;, &#34;metal_tool&#34;)

    # Constructor.
    def __init__(self, dir_model=None):
        &#34;&#34;&#34;
        Constructs an object that will perform the metal sites prediction.

        :param dir_model: (Path) Directory where the trained ANN model exist.
        &#34;&#34;&#34;

        # Make sure the target is Path.
        self.dir_model = Path(dir_model)

        # Make sure the model exists.
        if not self.dir_model.is_file():
            raise FileNotFoundError(f&#34;{self.__class__.__name__}: &#34;
                                    f&#34;Target model doesn&#39;t exist: {self.dir_model}.&#34;)
        # _end_if_

        # Load the (target) neural network model.
        self.nn_model = joblib.load(self.dir_model)

        # Get the hash of the loaded model.
        hash_code = joblib.hash(self.nn_model, hash_name=&#39;md5&#39;)

        # Check the &#39;md5-hash&#39; of the loaded files.
        if hash_code not in MD5_HASH_CODES.values():

            # Show a warning message instead of an error.
            warnings.warn(&#34;Unknown MD5-hash code for the loaded model.&#34;)

        # _end_if_

        # For parsing the PDB/CSD files.
        self.metal_tool = MetalPdbData(compute_angles=True)
    # _end_def_

    @property
    def model_path(self):
        &#34;&#34;&#34;
        Accessor (getter) of the model input path.

        :return: dir_model.
        &#34;&#34;&#34;
        return self.dir_model

    # _end_def_

    def predict(self, f_path):
        &#34;&#34;&#34;
        Primary method of a &#34;MetalSitesPredictor&#34; class. It accepts a PDB file
        as input, constructs the input vector and passes it to the trained NN.

        :param f_path: (string) PDB file with the residue / atom coordinates.

        :return: the predicted (with the highest probability) class and its
        entropy value.
        &#34;&#34;&#34;

        # Make sure the input file is a Path.
        f_path = Path(f_path)

        # Sanity check.
        if not f_path.is_file():
            raise FileNotFoundError(f&#34;{self.__class__.__name__} : &#34;
                                    f&#34;File {f_path} doesn&#39;t exist.&#34;)
        # _end_if_

        # Run the analysis. With fixed settings.
        self.metal_tool(f_path, max_length=8, n_closest=6)

        # Create the feature vector.
        x_test = np.array(self.metal_tool.features_vector())

        # Get the prediction probabilities.
        y_probs = self.nn_model.predict_proba(x_test.reshape(1, -1))

        # Remove the singleton dimension. It makes
        # the rest of the function calls faster.
        y_probs = y_probs.squeeze()

        # Compute the entropy (using the probabilities).
        y_entropy = fast_entropy(y_probs)

        # Return the class with the highest probability,
        # and it&#39;s entropy value.
        return np.argmax(y_probs), np.maximum(y_entropy, 0.0)
    # _end_def_

    # Auxiliary.
    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        This is only a &#34;wrapper&#34; method of the
        predict() method.
        &#34;&#34;&#34;
        return self.predict(*args, **kwargs)
    # _end_def_

    # Auxiliary.
    def __str__(self):
        &#34;&#34;&#34;
        Override to print a readable string presentation of the
        object. This will include its id() along with its field
        values.

        :return: a string representation of a MetalSitesPredictor
        object.
        &#34;&#34;&#34;

        return f&#34; MetalSitesPredictor Id({id(self)}): \n&#34; \
               f&#34; Model path: {self.dir_model} \n&#34; \
               f&#34; Model pipe: {self.nn_model}&#34;
    # _end_def_

# _end_class_</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor"><code class="flex name class">
<span>class <span class="ident">MetalSitesPredictor</span></span>
<span>(</span><span>dir_model=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Metal Sites Predictor class. This is the "wrapper" class that performs the
predictions in the input vectors. It processes the input (PDB) files, extracts
the features and finally performs the prediction using pre-trained models.</p>
<p>Constructs an object that will perform the metal sites prediction.</p>
<p>:param dir_model: (Path) Directory where the trained ANN model exist.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetalSitesPredictor(object):
    &#34;&#34;&#34;
    Metal Sites Predictor class. This is the &#34;wrapper&#34; class that performs the
    predictions in the input vectors. It processes the input (PDB) files, extracts
    the features and finally performs the prediction using pre-trained models.
    &#34;&#34;&#34;

    # Object variables.
    __slots__ = (&#34;nn_model&#34;, &#34;dir_model&#34;, &#34;metal_tool&#34;)

    # Constructor.
    def __init__(self, dir_model=None):
        &#34;&#34;&#34;
        Constructs an object that will perform the metal sites prediction.

        :param dir_model: (Path) Directory where the trained ANN model exist.
        &#34;&#34;&#34;

        # Make sure the target is Path.
        self.dir_model = Path(dir_model)

        # Make sure the model exists.
        if not self.dir_model.is_file():
            raise FileNotFoundError(f&#34;{self.__class__.__name__}: &#34;
                                    f&#34;Target model doesn&#39;t exist: {self.dir_model}.&#34;)
        # _end_if_

        # Load the (target) neural network model.
        self.nn_model = joblib.load(self.dir_model)

        # Get the hash of the loaded model.
        hash_code = joblib.hash(self.nn_model, hash_name=&#39;md5&#39;)

        # Check the &#39;md5-hash&#39; of the loaded files.
        if hash_code not in MD5_HASH_CODES.values():

            # Show a warning message instead of an error.
            warnings.warn(&#34;Unknown MD5-hash code for the loaded model.&#34;)

        # _end_if_

        # For parsing the PDB/CSD files.
        self.metal_tool = MetalPdbData(compute_angles=True)
    # _end_def_

    @property
    def model_path(self):
        &#34;&#34;&#34;
        Accessor (getter) of the model input path.

        :return: dir_model.
        &#34;&#34;&#34;
        return self.dir_model

    # _end_def_

    def predict(self, f_path):
        &#34;&#34;&#34;
        Primary method of a &#34;MetalSitesPredictor&#34; class. It accepts a PDB file
        as input, constructs the input vector and passes it to the trained NN.

        :param f_path: (string) PDB file with the residue / atom coordinates.

        :return: the predicted (with the highest probability) class and its
        entropy value.
        &#34;&#34;&#34;

        # Make sure the input file is a Path.
        f_path = Path(f_path)

        # Sanity check.
        if not f_path.is_file():
            raise FileNotFoundError(f&#34;{self.__class__.__name__} : &#34;
                                    f&#34;File {f_path} doesn&#39;t exist.&#34;)
        # _end_if_

        # Run the analysis. With fixed settings.
        self.metal_tool(f_path, max_length=8, n_closest=6)

        # Create the feature vector.
        x_test = np.array(self.metal_tool.features_vector())

        # Get the prediction probabilities.
        y_probs = self.nn_model.predict_proba(x_test.reshape(1, -1))

        # Remove the singleton dimension. It makes
        # the rest of the function calls faster.
        y_probs = y_probs.squeeze()

        # Compute the entropy (using the probabilities).
        y_entropy = fast_entropy(y_probs)

        # Return the class with the highest probability,
        # and it&#39;s entropy value.
        return np.argmax(y_probs), np.maximum(y_entropy, 0.0)
    # _end_def_

    # Auxiliary.
    def __call__(self, *args, **kwargs):
        &#34;&#34;&#34;
        This is only a &#34;wrapper&#34; method of the
        predict() method.
        &#34;&#34;&#34;
        return self.predict(*args, **kwargs)
    # _end_def_

    # Auxiliary.
    def __str__(self):
        &#34;&#34;&#34;
        Override to print a readable string presentation of the
        object. This will include its id() along with its field
        values.

        :return: a string representation of a MetalSitesPredictor
        object.
        &#34;&#34;&#34;

        return f&#34; MetalSitesPredictor Id({id(self)}): \n&#34; \
               f&#34; Model path: {self.dir_model} \n&#34; \
               f&#34; Model pipe: {self.nn_model}&#34;
    # _end_def_</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor.dir_model"><code class="name">var <span class="ident">dir_model</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor.metal_tool"><code class="name">var <span class="ident">metal_tool</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor.model_path"><code class="name">var <span class="ident">model_path</span></code></dt>
<dd>
<div class="desc"><p>Accessor (getter) of the model input path.</p>
<p>:return: dir_model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def model_path(self):
    &#34;&#34;&#34;
    Accessor (getter) of the model input path.

    :return: dir_model.
    &#34;&#34;&#34;
    return self.dir_model</code></pre>
</details>
</dd>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor.nn_model"><code class="name">var <span class="ident">nn_model</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="MetalHawk.src.model_predictor.MetalSitesPredictor.predict"><code class="name flex">
<span>def <span class="ident">predict</span></span>(<span>self, f_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Primary method of a "MetalSitesPredictor" class. It accepts a PDB file
as input, constructs the input vector and passes it to the trained NN.</p>
<p>:param f_path: (string) PDB file with the residue / atom coordinates.</p>
<p>:return: the predicted (with the highest probability) class and its
entropy value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict(self, f_path):
    &#34;&#34;&#34;
    Primary method of a &#34;MetalSitesPredictor&#34; class. It accepts a PDB file
    as input, constructs the input vector and passes it to the trained NN.

    :param f_path: (string) PDB file with the residue / atom coordinates.

    :return: the predicted (with the highest probability) class and its
    entropy value.
    &#34;&#34;&#34;

    # Make sure the input file is a Path.
    f_path = Path(f_path)

    # Sanity check.
    if not f_path.is_file():
        raise FileNotFoundError(f&#34;{self.__class__.__name__} : &#34;
                                f&#34;File {f_path} doesn&#39;t exist.&#34;)
    # _end_if_

    # Run the analysis. With fixed settings.
    self.metal_tool(f_path, max_length=8, n_closest=6)

    # Create the feature vector.
    x_test = np.array(self.metal_tool.features_vector())

    # Get the prediction probabilities.
    y_probs = self.nn_model.predict_proba(x_test.reshape(1, -1))

    # Remove the singleton dimension. It makes
    # the rest of the function calls faster.
    y_probs = y_probs.squeeze()

    # Compute the entropy (using the probabilities).
    y_entropy = fast_entropy(y_probs)

    # Return the class with the highest probability,
    # and it&#39;s entropy value.
    return np.argmax(y_probs), np.maximum(y_entropy, 0.0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="MetalHawk.src" href="index.html">MetalHawk.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor" href="#MetalHawk.src.model_predictor.MetalSitesPredictor">MetalSitesPredictor</a></code></h4>
<ul class="">
<li><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor.dir_model" href="#MetalHawk.src.model_predictor.MetalSitesPredictor.dir_model">dir_model</a></code></li>
<li><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor.metal_tool" href="#MetalHawk.src.model_predictor.MetalSitesPredictor.metal_tool">metal_tool</a></code></li>
<li><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor.model_path" href="#MetalHawk.src.model_predictor.MetalSitesPredictor.model_path">model_path</a></code></li>
<li><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor.nn_model" href="#MetalHawk.src.model_predictor.MetalSitesPredictor.nn_model">nn_model</a></code></li>
<li><code><a title="MetalHawk.src.model_predictor.MetalSitesPredictor.predict" href="#MetalHawk.src.model_predictor.MetalSitesPredictor.predict">predict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>